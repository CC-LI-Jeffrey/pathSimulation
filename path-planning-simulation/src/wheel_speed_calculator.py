import math
import numpy as np

class WheelSpeedCalculator:
    """
    Calculates wheel speeds based on the paths generated by WheelPathGenerator.
    Uses the distance between consecutive points to determine speed ratios.
    """
    
    def __init__(self, wheel_paths):
        """
        Initialize with the wheel paths for all four wheels.
        
        Args:
            wheel_paths: Dictionary mapping wheel IDs to lists of path points
        """
        self.wheel_paths = wheel_paths
        self.wheel_distances = {}
        self.wheel_speeds = {}
        self.total_distance = {}
        
        # Calculate distances between consecutive points for each wheel
        for wheel_id, points in wheel_paths.items():
            self.wheel_distances[wheel_id] = []
            total = 0
            
            for i in range(len(points) - 1):
                x1, y1 = points[i]
                x2, y2 = points[i + 1]
                distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
                self.wheel_distances[wheel_id].append(distance)
                total += distance
            
            self.total_distance[wheel_id] = total
    
    def calculate_speed_ratios(self):
        """
        Calculate the speed ratio for each wheel at each point.
        
        Returns:
            Dictionary mapping wheel IDs to lists of speed ratios
        """
        # Find maximum distance for normalization
        max_total_distance = max(self.total_distance.values())
        
        # Calculate speed ratios
        for wheel_id, distances in self.wheel_distances.items():
            # Calculate speed scale factor to ensure all wheels complete the path at the same time
            scale_factor = max_total_distance / self.total_distance[wheel_id] if self.total_distance[wheel_id] > 0 else 1
            
            # Calculate scaled speeds
            self.wheel_speeds[wheel_id] = [d * scale_factor for d in distances]
        
        return self.wheel_speeds
    
    def get_speed_at_progress(self, progress, base_speed=1.0):
        """
        Get wheel speeds at a specific progress point along the path.
        
        Args:
            progress: Progress along the path (0 to 1)
            base_speed: Base speed value to scale the ratios
            
        Returns:
            Dictionary mapping wheel IDs to speed values
        """
        if not self.wheel_speeds:
            self.calculate_speed_ratios()
        
        result = {}
        
        for wheel_id, speeds in self.wheel_speeds.items():
            if not speeds:
                result[wheel_id] = base_speed
                continue
                
            # Find the speed at this progress point
            index = min(int(progress * len(speeds)), len(speeds) - 1)
            
            # Get the speed at this index
            speed = speeds[index]
            
            # Map to motor IDs (orientation motors are odd, speed motors are even)
            speed_motor_id = wheel_id + 1  # e.g., wheel 1 -> motor 2
            
            # Store result
            result[speed_motor_id] = speed * base_speed
        
        return result
    
    def normalize_speeds(self, speeds, min_speed=-1.0, max_speed=1.0):
        """
        Normalize speeds to be within the specified range.
        
        Args:
            speeds: Dictionary mapping motor IDs to speed values
            min_speed: Minimum speed value
            max_speed: Maximum speed value
            
        Returns:
            Dictionary of normalized speeds
        """
        if not speeds:
            return {}
        
        # Find the maximum absolute speed
        max_abs_speed = max(abs(speed) for speed in speeds.values())
        
        if max_abs_speed == 0:
            return {motor_id: 0 for motor_id in speeds}
        
        # Calculate the scaling factor
        scale = max(abs(min_speed), abs(max_speed)) / max_abs_speed
        
        # Scale speeds
        return {motor_id: speed * scale for motor_id, speed in speeds.items()}
    
    def visualize_speeds(self, num_samples=10):
        """
        Visualize speed ratios at regular intervals along the path.
        
        Args:
            num_samples: Number of sample points to display
            
        Returns:
            String representation of the speed ratios
        """
        if not self.wheel_speeds:
            self.calculate_speed_ratios()
        
        result = "=== Wheel Speed Ratios ===\n"
        wheel_ids = sorted(self.wheel_speeds.keys())
        
        # Print header
        result += f"{'Progress':<10}"
        for wheel_id in wheel_ids:
            result += f"Wheel {wheel_id:<8}"
        result += "\n"
        
        # Sample speeds at regular intervals
        for i in range(num_samples + 1):
            progress = i / num_samples
            result += f"{progress:.2f}      "
            
            # Get speeds at this progress
            speeds = self.get_speed_at_progress(progress)
            
            # Print speeds
            for wheel_id in wheel_ids:
                speed_motor_id = wheel_id + 1
                if speed_motor_id in speeds:
                    result += f"{speeds[speed_motor_id]:.4f}    "
                else:
                    result += "N/A        "
            
            result += "\n"
        
        return result